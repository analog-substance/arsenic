#!/usr/bin/env arsenic

fmt := import("fmt")
text := import("text")
os := import("os")
filepath := import("filepath")
slice := import("slice")
arsenic := import("arsenic")
url := import("url")
script := import("script")
times := import("times")
log := import("log")
rand := import("rand")
git := import("git")
exec := import("exec")
os2 := import("os2")
cobra := import("cobra")


getHosts := func(flags) {
  err := git.pull()
  if is_error(err) {
    script.stop(err)
  }
  
  hosts := []
  allHosts := arsenic.hosts(flags)
  if is_error(allHosts) {
    script.stop(allHosts)
  }

  for host in allHosts {
    files := host.files(filepath.join("recon", "nmap*udp*"))
    if len(files) > 0 {
      continue
    }

    hosts = append(hosts, host)
  }

  return hosts
}

flags := []

rootCmd := cobra.root_cmd("as-port-scan-udp.tengo", "Run nmap UDP scans on current scope")
rootCmd.persistent_flags.string_slicep("flags", "f", [], "Filter hosts by flags")

rootCmd.set_persistent_pre_run(func(cmd, args) {
  flags = cmd.flags.get_string_slice("flags")

  err := git.pull()
  if is_error(err) {
    script.stop(err)
  }
})

listCmd := cobra.cmd("list", "Lists the hosts that need nmap UDP scans.")
rootCmd.add_command(listCmd)

listCmd.set_run(func(cmd, args) {
	hosts := getHosts(flags)
  for host in hosts {
    fmt.println(host.name)
  }
})

scanCmd := cobra.cmd("scan", "Scan hosts that need nmap UDP scans.")
scanCmd.flags.stringp("host", "H", "", "Host to scan.")
rootCmd.add_command(scanCmd)

scanCmd.set_run(func(cmd, args) {
  targetHost := undefined
  targetHostName := cmd.flags.get_string("host")

  manual := targetHostName != ""

  autoSelect := func() {
    targetHost = slice.rand_item(getHosts(flags))
    if !targetHost {
      files := arsenic.locked_files("hosts/*/recon/nmap-punched-quick-udp.nmap")
      if is_error(files) {
        script.stop(files)
      }

      if len(files) > 0 {
        log.warn("other UDP port scans are still running... lets wait before continuing")
        script.stop()
      }

      script.stop("No host found")
    }
    
    log.warn(format("Auto selected %s", targetHost.name))
  }

  scanHost := func(host) {
    if !host {
      return
    }

    log.msg(format("Port Scan / UDP / %s/ checking", host.name))

    reconPath := filepath.join(host.dir, "recon")

    files := host.files(filepath.join(reconPath, "nmap*udp*"))
    if is_error(files) {
      script.stop(files)
    }

    if len(files) != 0 {
      return
    }

    log.info(format("Port Scan / UDP / %s / preparing", host.name))

    os.mkdir_all(reconPath, 0755)

    err := git.lock(filepath.join(reconPath, "nmap-punched-udp.nmap"), format("UDP port scan lock: %s", host.name))
    if is_error(err) {
      script.stop(err)
    }

    previousDir := os.getwd()
    if is_error(previousDir) {
      script.stop(previousDir)
    }

    err = os.chdir(host.dir)
    if is_error(err) {
      script.stop(err)
    }

    log.info(format("Port Scan / UDP / %s / running", host.name))

    err = exec.run_with_sig_handler("sudo", "nmap", "--stylesheet", "/static/nmap.xsl", "-oA", "recon/nmap-punched-udp", "-sUV", "-p-", "-Pn", "--max-rtt-timeout", "100ms", "--min-rate", "1000", "--version-intensity", "0", host.name)
    if is_error(err) {
      script.stop(err)
    }

    err = os2.regex_replace_file(filepath.join("recon", "nmap-punched-udp.xml"), `"[^"]*nmap\.xsl"`, `"/static/nmap.xsl"`)
    if is_error(err) {
      script.stop(err)
    }

    err = git.commit(".", format("UDP port scan complete: %s", host.name))
    if is_error(err) {
      script.stop(err)
    }

    err = os.chdir(previousDir)
    if is_error(err){
      script.stop(err)
    }

    log.info(format("Port Scan / UDP / %s / complete", host.name))
  }

  if manual {
    targetHost = arsenic.host(targetHostName)
    if is_error(targetHost) {
      script.stop(targetHost)
    }
  } else {
    log.warn("no args found, autodetecting")

    autoSelect()
  }

  for {
    scanHost(targetHost)

    if manual {
      break
    }

    autoSelect()
  }
})

err := rootCmd()
if is_error(err) {
	script.stop(err)
}
